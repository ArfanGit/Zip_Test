/**
 * Import Sodexo/Mashie weekly menu JSON files into Supabase tables:
 *   restaurants -> dishes -> dish_components -> component_ingredients
 *
 * NOTE:
 * - restaurants.id stays UUID (generated by DB).
 * - dish_components no longer writes is_main_component or plate_share_source.
 * - component_type/plate_share are left NULL/unknown here; AI script fills them later.
 *
 * Usage examples:
 *   npx ts-node src/importSodexoMenus.ts --files sodexo_data_62.json,sodexo_data_65.json,sodexo_data_68.json,sodexo_data_69.json --city Espoo
 *   npx ts-node src/importSodexoMenus.ts --dir . --prefix sodexo_data_ --city Espoo
 *
 * Env (.env):
 *   SUPABASE_URL=...
 *   SUPABASE_SERVICE_ROLE_KEY=...
 */

import "dotenv/config";
import fs from "node:fs";
import path from "node:path";
import { createClient } from "@supabase/supabase-js";

type JsonMeta = {
  generated_timestamp: number; // epoch seconds
  ref_url?: string;
  ref_title?: string; // branch name (e.g., "Keilaranta 1")
  restaurant_mashie_id?: string;
};

type JsonRecipe = {
  name?: string;
  ingredients?: string;
  nutrients?: string;
  dietcodes?: string;
};

type JsonCourse = {
  title_fi?: string;
  title_en?: string;
  title_sv?: string;
  category?: string;
  meal_category?: string;
  dietcodes?: string;
  recipes?: Record<string, JsonRecipe | any>;
};

type JsonMealDate = {
  date: string; // e.g. "Monday" or ISO date
  courses: Record<string, JsonCourse>;
};

type SodexoJson = {
  meta: JsonMeta;
  timeperiod?: string; // e.g. "22.12. - 28.12."
  mealdates: JsonMealDate[];
};

type DishRow = { id: number };
type ComponentRow = { id: number };

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  throw new Error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY in .env");
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
  auth: { persistSession: false },
});

/** -----------------------------
 * CLI args
 * ------------------------------ */
function getArg(name: string): string | null {
  const idx = process.argv.findIndex((a) => a === name);
  if (idx === -1) return null;
  return process.argv[idx + 1] ?? null;
}

function parseFilesArg(v: string | null): string[] {
  if (!v) return [];
  return v
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);
}

/** -----------------------------
 * Date helpers
 * ------------------------------ */
function pad2(n: number): string {
  return String(n).padStart(2, "0");
}

function dateUTC(y: number, m1: number, d: number): Date {
  return new Date(Date.UTC(y, m1 - 1, d));
}

function addDaysUTC(d: Date, days: number): Date {
  const out = new Date(d.getTime());
  out.setUTCDate(out.getUTCDate() + days);
  return out;
}

function formatDateUTC(d: Date): string {
  return `${d.getUTCFullYear()}-${pad2(d.getUTCMonth() + 1)}-${pad2(d.getUTCDate())}`;
}

function parseTimeperiod(tp: string, baseYear: number): { start: Date; end: Date } | null {
  const m = tp.match(/(\d{1,2})\.(\d{1,2})\.\s*-\s*(\d{1,2})\.(\d{1,2})\./);
  if (!m) return null;

  const sd = Number(m[1]);
  const sm = Number(m[2]);
  const ed = Number(m[3]);
  const em = Number(m[4]);

  const start = dateUTC(baseYear, sm, sd);
  const endYear = em < sm || (em === sm && ed < sd) ? baseYear + 1 : baseYear;
  const end = dateUTC(endYear, em, ed);

  return { start, end };
}

const DOW: Record<string, number> = {
  monday: 0,
  tuesday: 1,
  wednesday: 2,
  thursday: 3,
  friday: 4,
  saturday: 5,
  sunday: 6,
};

function mondayIndexUTC(d: Date): number {
  return (d.getUTCDay() + 6) % 7;
}

function inferMenuDateISO(mealDateStr: string, startDate: Date): string | null {
  if (/^\d{4}-\d{2}-\d{2}$/.test(mealDateStr)) return mealDateStr;

  const key = mealDateStr.trim().toLowerCase();
  if (key in DOW) {
    const startDow = mondayIndexUTC(startDate);
    const targetDow = DOW[key];
    const delta = (targetDow - startDow + 7) % 7;
    return formatDateUTC(addDaysUTC(startDate, delta));
  }

  const m = mealDateStr.match(/(\d{1,2})\.(\d{1,2})\./);
  if (m) {
    const d = Number(m[1]);
    const mo = Number(m[2]);
    const y = startDate.getUTCFullYear();
    const yy = mo < (startDate.getUTCMonth() + 1) ? y + 1 : y;
    return formatDateUTC(dateUTC(yy, mo, d));
  }

  return null;
}

/** -----------------------------
 * Ingredient parsing helpers
 * ------------------------------ */
function parseTrailingSharePct(token: string): number | null {
  const m = token.match(/\((\d+(?:[.,]\d+)?)%\)\s*$/);
  if (!m) return null;
  const v = Number(m[1].replace(",", "."));
  return Number.isFinite(v) ? v : null;
}

function removeTrailingShare(token: string): string {
  return token.replace(/\(\d+(?:[.,]\d+)?%\)\s*$/, "").trim();
}

/**
 * Split ingredients by commas, but do NOT split commas inside:
 *  - square brackets [...]
 *  - parentheses (...)
 */
function splitTopLevelIngredients(s: string): string[] {
  const out: string[] = [];
  let cur = "";
  let sq = 0;
  let par = 0;

  for (let i = 0; i < s.length; i++) {
    const ch = s[i];

    if (ch === "[") sq++;
    if (ch === "]" && sq > 0) sq--;
    if (ch === "(") par++;
    if (ch === ")" && par > 0) par--;

    if (ch === "," && sq === 0 && par === 0) {
      const t = cur.trim();
      if (t) out.push(t);
      cur = "";
      continue;
    }
    cur += ch;
  }

  const last = cur.trim();
  if (last) out.push(last);
  return out;
}

function extractBaseAndDescription(tokenNoShare: string): { base: string; desc: string | null } {
  const i = tokenNoShare.indexOf("[");
  if (i === -1) return { base: tokenNoShare.trim(), desc: null };

  const j = tokenNoShare.lastIndexOf("]");
  if (j === -1 || j < i) return { base: tokenNoShare.trim(), desc: null };

  const base = tokenNoShare.slice(0, i).trim();
  const desc = tokenNoShare.slice(i + 1, j).trim();
  return { base: base || tokenNoShare.trim(), desc: desc || null };
}

function normalizeIngredientCore(base: string): string {
  let s = base.trim().toUpperCase();
  s = s.replace(/Ä/g, "A").replace(/Ö/g, "O").replace(/Å/g, "A");
  s = s.replace(/\b\d+[.,]?\d*\s*(KG|G|L|DL|CL|ML)\b/g, " ");
  s = s.replace(/\b\d+[.,]?\d*\b/g, " ");
  s = s.replace(/\b(RTU|KPA|LTN|TANKO)\b/g, " ");
  s = s.replace(/[^A-Z0-9]+/g, "_");
  s = s.replace(/_+/g, "_").replace(/^_+|_+$/g, "");
  return s || "UNKNOWN";
}

function isWater(base: string): boolean {
  return /^vesi\b/i.test(base.trim());
}

function isSalt(base: string): boolean {
  return /\bsuola\b/i.test(base.trim());
}

/** -----------------------------
 * DB operations
 * ------------------------------ */
async function findRestaurantIdByExternal(externalSystem: string, externalId: string): Promise<string | null> {
  const { data, error } = await supabase
    .from("restaurants")
    .select("id")
    .eq("external_system", externalSystem)
    .eq("external_restaurant_id", externalId)
    .limit(1);

  if (error) throw error;
  return data && data.length ? (data[0] as any).id : null;
}

async function findRestaurantIdByHuman(sourceSystem: string, branchName: string, city: string | null): Promise<string | null> {
  let q = supabase
    .from("restaurants")
    .select("id")
    .eq("source_system", sourceSystem)
    .eq("branch_name", branchName);

  q = city === null ? q.is("city", null) : q.eq("city", city);

  const { data, error } = await q.limit(1);
  if (error) throw error;
  return data && data.length ? (data[0] as any).id : null;
}

async function upsertRestaurant(params: {
  source_system: string;
  branch_name: string;
  city: string | null;
  external_system: string | null;
  external_restaurant_id: string | null;
  ref_url: string | null;
}): Promise<string> {
  const { source_system, branch_name, city, external_system, external_restaurant_id, ref_url } = params;

  if (external_system && external_restaurant_id) {
    const existingByExt = await findRestaurantIdByExternal(external_system, external_restaurant_id);
    if (existingByExt) {
      const { error } = await supabase
        .from("restaurants")
        .update({ source_system, branch_name, city, ref_url })
        .eq("id", existingByExt);
      if (error) throw error;
      return existingByExt;
    }
  }

  const existingByHuman = await findRestaurantIdByHuman(source_system, branch_name, city);
  if (existingByHuman) {
    const { error } = await supabase
      .from("restaurants")
      .update({ external_system, external_restaurant_id, ref_url })
      .eq("id", existingByHuman);
    if (error) throw error;
    return existingByHuman;
  }

  const { data, error } = await supabase
    .from("restaurants")
    .insert({ source_system, branch_name, city, external_system, external_restaurant_id, ref_url })
    .select("id")
    .single();

  if (error) throw error;
  return (data as any).id as string;
}

async function upsertDish(params: {
  restaurant_id: string;
  menu_date: string; // YYYY-MM-DD
  sodexo_course_id: string;
  title_fi: string;
  title_en: string | null;
  title_sv: string | null;
  category: string | null;
  dietcodes: string | null;
}): Promise<number> {
  const { data, error } = await supabase
    .from("dishes")
    .upsert(params, { onConflict: "restaurant_id,menu_date,sodexo_course_id" })
    .select("id")
    .single();

  if (error) throw error;
  return (data as DishRow).id;
}

async function upsertDishComponent(params: {
  dish_id: number;
  sodexo_recipe_key: string;
  name_raw: string;
  ingredients_raw: string | null;
  nutrients_raw: string | null;
}): Promise<number> {
  const { data, error } = await supabase
    .from("dish_components")
    .upsert(params, { onConflict: "dish_id,sodexo_recipe_key" })
    .select("id")
    .single();

  if (error) throw error;
  return (data as ComponentRow).id;
}

async function replaceComponentIngredients(componentId: number, rows: any[]): Promise<void> {
  const { error: delErr } = await supabase.from("component_ingredients").delete().eq("component_id", componentId);
  if (delErr) throw delErr;

  if (!rows.length) return;

  const { error: insErr } = await supabase.from("component_ingredients").insert(rows);
  if (insErr) throw insErr;
}

/** -----------------------------
 * JSON import pipeline
 * ------------------------------ */
function getYearFromGeneratedTimestamp(ts: number): number {
  const d = new Date(ts * 1000);
  return d.getUTCFullYear();
}

function isNumericKey(k: string): boolean {
  return /^\d+$/.test(k);
}

async function importOneFile(filePath: string, opts: { city: string | null; addRemainderBucket: boolean }) {
  const abs = path.isAbsolute(filePath) ? filePath : path.join(process.cwd(), filePath);
  if (!fs.existsSync(abs)) throw new Error(`File not found: ${abs}`);

  const raw = fs.readFileSync(abs, "utf8");
  const json = JSON.parse(raw) as SodexoJson;

  if (!json.meta || !json.mealdates) throw new Error(`Invalid JSON structure: ${abs}`);

  const source_system = "SODEXO";
  const branch_name = (json.meta.ref_title || "UNKNOWN").trim();
  const ref_url = json.meta.ref_url ? String(json.meta.ref_url) : null;
  const external_system = json.meta.restaurant_mashie_id ? "MASHIE" : null;
  const external_restaurant_id = json.meta.restaurant_mashie_id ? String(json.meta.restaurant_mashie_id) : null;

  const restaurantId = await upsertRestaurant({
    source_system,
    branch_name,
    city: opts.city,
    external_system,
    external_restaurant_id,
    ref_url,
  });

  const baseYear = getYearFromGeneratedTimestamp(json.meta.generated_timestamp);
  const tp = json.timeperiod || "";
  const parsedTp = tp ? parseTimeperiod(tp, baseYear) : null;
  if (!parsedTp) {
    throw new Error(`Cannot parse timeperiod "${tp}" in ${path.basename(abs)}.`);
  }
  const startDate = parsedTp.start;

  let dishesCount = 0;
  let componentsCount = 0;
  let ingredientsRowsCount = 0;

  for (const md of json.mealdates) {
    const menuDate = inferMenuDateISO(md.date, startDate);
    if (!menuDate) {
      console.warn(`[WARN] Skipping unrecognized date "${md.date}" in ${abs}`);
      continue;
    }

    const courses = md.courses || {};
    for (const [courseKey, course] of Object.entries(courses)) {
      if (!isNumericKey(courseKey)) continue;

      const title_fi = (course.title_fi || "").trim();
      if (!title_fi) continue;

      const title_en = course.title_en ? String(course.title_en).trim() : null;
      const title_sv = (course as any).title_sv ? String((course as any).title_sv).trim() : null;
      const category = course.category ? String(course.category).trim() : null;
      const dietcodes = course.dietcodes ? String(course.dietcodes).trim() : null;

      const dishId = await upsertDish({
        restaurant_id: restaurantId,
        menu_date: menuDate,
        sodexo_course_id: courseKey,
        title_fi,
        title_en,
        title_sv,
        category,
        dietcodes,
      });
      dishesCount++;

      const recipes = course.recipes || {};
      const recipeEntries = Object.entries(recipes).filter(([k, v]) => isNumericKey(k) && v && typeof v === "object");

      for (const [recipeKey, recipeAny] of recipeEntries) {
        const recipe = recipeAny as JsonRecipe;
        const name_raw = (recipe.name || "").trim();
        if (!name_raw) continue;

        const ingredients_raw = recipe.ingredients ? String(recipe.ingredients) : null;
        const nutrients_raw = recipe.nutrients ? String(recipe.nutrients) : null;

        const componentId = await upsertDishComponent({
          dish_id: dishId,
          sodexo_recipe_key: recipeKey,
          name_raw,
          ingredients_raw,
          nutrients_raw,
        });
        componentsCount++;

        if (!ingredients_raw) continue;

        const tokens = splitTopLevelIngredients(ingredients_raw);

        const rows: any[] = [];
        let seq = 1;

        let declaredSum = 0;
        const missing: string[] = [];

        for (const token of tokens) {
          const share = parseTrailingSharePct(token);
          if (share !== null) declaredSum += share;

          const tokenNoShare = removeTrailingShare(token);
          const { base, desc } = extractBaseAndDescription(tokenNoShare);

          const core = normalizeIngredientCore(base);
          const water = isWater(base);
          const salt = isSalt(base);

          if (share === null) missing.push(token);

          rows.push({
            component_id: componentId,
            seq_no: seq++,
            ingredient_raw: token,
            base_name: base,
            description: desc,
            share_of_component: share,
            share_source: share !== null ? "declared_top" : "unknown",
            ingredient_core: core,
            is_water: water,
            is_salt: salt,
            description_facts: null,
          });
        }

        if (opts.addRemainderBucket && declaredSum > 0 && declaredSum < 100 && missing.length > 0) {
          const remainder = Math.max(0, 100 - declaredSum);
          rows.push({
            component_id: componentId,
            seq_no: seq++,
            ingredient_raw: "OTHER_UNSPECIFIED",
            base_name: "OTHER_UNSPECIFIED",
            description: missing.join(", "),
            share_of_component: remainder,
            share_source: "remainder_bucket",
            ingredient_core: "OTHER_UNSPECIFIED",
            is_water: false,
            is_salt: false,
            description_facts: { missing_count: missing.length },
          });
        }

        await replaceComponentIngredients(componentId, rows);
        ingredientsRowsCount += rows.length;
      }
    }
  }

  console.log(
    `[OK] Imported ${path.basename(abs)} -> restaurant:${restaurantId} dishes:${dishesCount} components:${componentsCount} ingredient_rows:${ingredientsRowsCount}`
  );
}

async function main() {
  const files = parseFilesArg(getArg("--files"));
  const dir = getArg("--dir");
  const prefix = getArg("--prefix") || "";
  const city = getArg("--city");
  const noRemainder = process.argv.includes("--no-remainder-bucket");

  let fileList: string[] = [];

  if (files.length) {
    fileList = files;
  } else if (dir) {
    const absDir = path.isAbsolute(dir) ? dir : path.join(process.cwd(), dir);
    const all = fs.readdirSync(absDir);
    fileList = all
      .filter((f) => f.toLowerCase().endsWith(".json"))
      .filter((f) => (prefix ? f.startsWith(prefix) : true))
      .map((f) => path.join(absDir, f));
  } else {
    const defaults = ["sodexo_data_62.json", "sodexo_data_65.json", "sodexo_data_68.json", "sodexo_data_69.json"];
    fileList = defaults.filter((f) => fs.existsSync(path.join(process.cwd(), f)));
    if (!fileList.length) {
      throw new Error("No files provided. Use --files a.json,b.json OR --dir . --prefix sodexo_data_");
    }
  }

  for (const f of fileList) {
    await importOneFile(f, { city: city ? String(city) : null, addRemainderBucket: !noRemainder });
  }

  console.log("[DONE] All imports complete.");
}

main().catch((err) => {
  console.error("[FAIL]", err);
  process.exit(1);
});
